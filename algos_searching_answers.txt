1. an example of this would be if you were searching for clothes sizes,
 if you need start at the begining of the line at small the work your way up until you find your size.

2. If you are at a music store that sells vinyls, if such store has a middle travel aisle,
and when you're standing in front of that aisle you have aisles to your left and to your right that are perpendicular
to the middle aisle. If they are in alphabetical order then the record you're looking for would be on one side of the store,
thus eliminating the need to look for it on the opposite side.

3. 7 iterations to find G.

4. 3 iterations to find G

5. Linear search, because binary search doesn't work with unsorted collections

6. Binary search, because it works with sorted collections and it would get search to it faster,
because it wouldn't have to check every single item in the collection unlike linear search.


PQ1.

var names = ["Albatross", "Baboon", "Cat", "Dog", "Falcon", "Killer Whale"];

function WordSearch(arr, word){
  var low = arr[0];
  var high = arr[arr.length -1];

  while (low <= high) {
    var mid = (arr.indexOf(low) + arr.indexOf(high)) / 2;
    mid = Math.round(mid);

    if(arr[mid] > word) {
      high = arr[mid -1];
    }
    else if (arr[mid] < word) {
      low = arr[mid + 1];
    }
    else {
      return arr[mid];
    }
  }
  return "That name is not in the list";
}

console.log(WordSearch(names, "Albatross"));



PQ2.

var fishTank = ["goldfish", "goldfish", "green swordtail",
			"commmon molly", "goldfish", "platy", "white-spotted goldfish"];

function NetFish(arr, target){
  for(var i = 0; i < arr.length; i++){
    if (arr[i] === target){
      return "You've net the only white-spotted goldfish from the fish tank";
    }
  }
  return "The he only white-spotted goldfish isn't in the tank .";
}

console.log(NetFish(fishTank, "white-spotted goldfish"));

1. 
 FUNCTION bubbleSort(collection)
   
   REPEAT
     SET swapped to false
     FOR i = FIRST INDEX of collection to LAST INDEX of collection - 1
       IF collection[i] > collection[i + 1] THEN
         SET tmp to collection[i]
         SET collection[i] to collection[i + 1]
         SET collection[i + 1] to tmp
         SET swapped to true
       END IF
     END FOR
   UNTIL swapped is FALSE
   RETURN collection
 END FUNCTION


2.
 FUNCTION quickSort(collection)
  SET low to 0
  SET high to collection -1
    IF low < high THEN
        SET pivot to partition WITH collection, low ,high
        CALL quickSort WITH collection, low, pivot
        CALL quickSort WITH collection, pivot + 1, high
    END IF
 END FUNCTION

 FUNCTION partition(collection, low, high){
     SET pivot to collection[low]
     SET leftwall to low

     FOR each item in collection
         IF collection[i] < pivot THEN
             swap collection[i] with collection[leftwall + 1]
             SET leftwall to leftwall + 1
         END IF
     END FOR
     swap WITH pivot, collection[leftwall]

    RETURN leftwall

3. Merge sort is a efficient algorithm because it can handle large collection without having 
to iterate through the same collection time and time again. It divides the collection into 
sub-collections and then merge them together in order. 
Quick sort is an effective algorithm because it can work with a large collection while using less memory. 
It doesn’t require to compare each item with one another, unlike other algorithms.

4. Bucket sort starts with an unsorted array, we then set up an array of empty buckets 
and depending on the items’ range we place them into the buckets. Finally we sort the items in the buckets, 
and we then we place them back into the original array.
Bucket sort works best when the data are more or less uniformly distributed 
or where there is an intelligent way to choose the buckets given a quick set of heuristics based on the input array

























